[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cartography with R",
    "section": "",
    "text": "Preamble\nProcess spatial data and create reproducible maps with R.\nTopics covered:\n\nThe R Spatial ecosystem\nSpatial data manipulation\nThematic cartography and graphic semiology\nMaps with R\nMap layout and map export\n\nHow to use the manual\nDatasets used in this document are stored in an RStudio project. You need to download it and unzip it on your machine. You will then be able to test all data processing proposed in this document using the geodata project.\nDownload project\nContribution and feedback\nYou can send your comments and suggestions by posting an issue on the GitHub repository of this document.\nContext\nThis document is an extract and a translation of Cartographie avec R (2024a) and G√©omatique avec R (2024b). It is the basis for a one-day course on geomatics and cartography with R.\nSee aslo\n\n\n\n\n\n\n\n\n\nLovelace, Nowosad, and Muenchow (2025)\n\n\n\n\n\n\n\nPebesma and Bivand (2023)\n\n\n\n\n\n\n\nHijmans (2025)\n\n\n\n\n\n\n\n\n\n\nGiraud, Timoth√©e, and Hugues Pecout. 2024a. ‚ÄúCartographie avec R.‚Äù https://doi.org/10.5281/zenodo.5905734.\n\n\n‚Äî‚Äî‚Äî. 2024b. ‚ÄúG√©omatique avec R.‚Äù https://doi.org/10.5281/zenodo.5906212.\n\n\nHijmans, Robert J. 2025. Spatial Data Science with R and \"terra\". https://rspatial.org.\n\n\nLovelace, Robin, Jakub Nowosad, and Jannes Muenchow. 2025. Geocomputation with R. Chapman; Hall/CRC. https://r.geocompx.org/.\n\n\nPebesma, Edzer, and Roger Bivand. 2023. Spatial Data Science: With applications in R. Chapman; Hall/CRC. https://doi.org/10.1201/9780429459016.",
    "crumbs": [
      "*Preamble*"
    ]
  },
  {
    "objectID": "0_spatial_ecosystem.html",
    "href": "0_spatial_ecosystem.html",
    "title": "1¬† Introduction",
    "section": "",
    "text": "The spatial ecosystem of R is rich, dynamic and mature and several packages can be used to import, process and represent spatial data.\nThe following short presentation is an overview of this ecosystem:\nüîó Introduction to the R Spatial Ecosystem\n\n\n\n\n\n\nSee also\n\n\n\n\nBivand, Roger. 2021. ‚ÄúProgress in the R Ecosystem for Representing and Handling Spatial Data.‚Äù Journal of Geographical Systems 23 (4): 515‚Äì46. https://doi.org/10.1007/s10109-020-00336-0.",
    "crumbs": [
      "**I. The Spatial Ecosystem**",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "1_vector_data.html",
    "href": "1_vector_data.html",
    "title": "2¬† Vector Data",
    "section": "",
    "text": "2.1 sf package\nPackage maintained by Pebesma (2018).\nMain features:",
    "crumbs": [
      "**II. Vector Data & Geoprocessing**",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector Data</span>"
    ]
  },
  {
    "objectID": "1_vector_data.html#sf-package",
    "href": "1_vector_data.html#sf-package",
    "title": "2¬† Vector Data",
    "section": "",
    "text": "¬© Allison Horst, 2018\n\n\n\n\nimport / export\ndisplay\ngeoprocessing\nsupport for unprojected data (on the globe)\nuse of the simple feature standard\ncompatibility with the pipe operators (|&gt; or %&gt;%)\n\ncompatibility with tidyverse operators.",
    "crumbs": [
      "**II. Vector Data & Geoprocessing**",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector Data</span>"
    ]
  },
  {
    "objectID": "1_vector_data.html#resources",
    "href": "1_vector_data.html#resources",
    "title": "2¬† Vector Data",
    "section": "2.2 Resources",
    "text": "2.2 Resources\n\n\n\n\n\n\n\n\n\nWebsite\n\n\n\n\n\n\n\nCheat sheet\n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nInstall the sf package.",
    "crumbs": [
      "**II. Vector Data & Geoprocessing**",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector Data</span>"
    ]
  },
  {
    "objectID": "1_vector_data.html#sf-format",
    "href": "1_vector_data.html#sf-format",
    "title": "2¬† Vector Data",
    "section": "2.3 sf format",
    "text": "2.3 sf format\n\n\n\n\n\n\nFrom How simple features in R are organized on sf website\n\n\n\nThe three classes used to represent simple features are:\n\nsf, the table (data.frame) with feature attributes and feature geometries, which contains\nsfc, the list-column with the geometries for each feature (record), which is composed of\nsfg, the feature geometry of an individual simple feature.\n\n We see:\n\nin green a simple feature: a single record, or data.frame row, consisting of attributes and geometry\nin blue a single simple feature geometry (an object of class sfg)\nin red a simple feature list-column (an object of class sfc, which is a column in the data.frame) that although geometries are native R objects, they are printed as well-known text",
    "crumbs": [
      "**II. Vector Data & Geoprocessing**",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector Data</span>"
    ]
  },
  {
    "objectID": "1_vector_data.html#import-and-export",
    "href": "1_vector_data.html#import-and-export",
    "title": "2¬† Vector Data",
    "section": "2.4 Import and export",
    "text": "2.4 Import and export\nThe st_read() and st_write() functions can be used to import and export a wide range of file types.\n\n2.4.1 Import\nThe st_read() function imports geographic layers in sf format.\nThe following lines import the layer of municipalities in the Lot department provided in the geopackage file lot.gpkg.\n\nlibrary(sf)\n\n#&gt; Linking to GEOS 3.13.0, GDAL 3.10.2, PROJ 9.5.1; sf_use_s2() is TRUE\n\nmun &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\")\n\n#&gt; Reading layer `communes' from data source \n#&gt;   `/home/tim/Documents/prj/cartography_with_r/data/lot.gpkg' \n#&gt;   using driver `GPKG'\n#&gt; Simple feature collection with 313 features and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 539668.5 ymin: 6346290 xmax: 637380.9 ymax: 6439668\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n\n\n\nclass(mun)\n\n#&gt; [1] \"sf\"         \"data.frame\"\n\n\n\n\n\n\n\n\nGeopackage\n\n\n\nThe geopackage format lets you store multiple layers in a single file.\nThe st_layers() function provides an overview of the layers present in a geopackage file.\n\nst_layers(\"data/lot.gpkg\")\n\n#&gt; Driver: GPKG \n#&gt; Available layers:\n#&gt;     layer_name geometry_type features fields              crs_name\n#&gt; 1     communes Multi Polygon      313     12 RGF93 v1 / Lambert-93\n#&gt; 2 departements Multi Polygon       96      5 RGF93 v1 / Lambert-93\n#&gt; 3  restaurants         Point      694      2 RGF93 v1 / Lambert-93\n#&gt; 4   elevations         Point     5228      1 RGF93 v1 / Lambert-93\n#&gt; 5       routes   Line String     1054      2 RGF93 v1 / Lambert-93",
    "crumbs": [
      "**II. Vector Data & Geoprocessing**",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector Data</span>"
    ]
  },
  {
    "objectID": "1_vector_data.html#export",
    "href": "1_vector_data.html#export",
    "title": "2¬† Vector Data",
    "section": "2.5 Export",
    "text": "2.5 Export\nThe following lines export the com object to the communes layer of the com.gpkg geopackage in the data folder.\n\nst_write(obj = mun, dsn = \"data/com.gpkg\", layer = \"communes\")\n\n#&gt; Writing layer `communes' to data source `data/com.gpkg' using driver `GPKG'\n#&gt; Writing 313 features with 12 fields and geometry type Multi Polygon.\n\n\n\n\n\n\n\n\nMore\n\n\n\nReading, Writing and Converting Simple Features, on sf website.\n\n\n\n\n\n\n\n\nExercice\n\n\n\nImport municipalities.",
    "crumbs": [
      "**II. Vector Data & Geoprocessing**",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector Data</span>"
    ]
  },
  {
    "objectID": "1_vector_data.html#explore-and-display",
    "href": "1_vector_data.html#explore-and-display",
    "title": "2¬† Vector Data",
    "section": "2.6 Explore and display",
    "text": "2.6 Explore and display\n\n2.6.1 Overview of variables\nThe sf objects are data.frame. We can use the head() or summary() functions.\n\nlibrary(sf)\nmun &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\nhead(mun, n = 3)\n\n#&gt; Simple feature collection with 3 features and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 557759.2 ymin: 6371852 xmax: 607179 ymax: 6418606\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;   INSEE_COM  NOM_COM         STATUT POPULATION     AGR_H    AGR_F     IND_H\n#&gt; 1     46001    Albas Commune simple        522  4.978581 0.000000  4.936153\n#&gt; 2     46002   Albiac Commune simple         67  0.000000 9.589041  0.000000\n#&gt; 3     46003 Alvignac Commune simple        706 10.419682 0.000000 10.419682\n#&gt;      IND_F     BTP_H BTP_F     TER_H     TER_F                           geom\n#&gt; 1 0.000000  9.957527     0 44.917145 34.681799 MULTIPOLYGON (((559262 6371...\n#&gt; 2 0.000000  4.794521     0  4.794521  9.589041 MULTIPOLYGON (((605540.7 64...\n#&gt; 3 5.209841 10.419682     0 57.308249 78.147612 MULTIPOLYGON (((593707.7 64...\n\n\n\n\n2.6.2 Plot\nData overview with plot() :\n\nplot(mun)\n\n#&gt; Warning: plotting the first 9 out of 12 attributes; use max.plot = 12 to plot\n#&gt; all\n\n\n\n\n\n\n\n\n\nDisplay a single variable:\n\nplot(mun[\"POPULATION\"])\n\n\n\n\n\n\n\n\nDisplay geometry only:\n\nplot(st_geometry(mun), col = \"ivory4\", border = \"ivory\")\n\n\n\n\n\n\n\n\nYou can also use the mapsf package (Giraud 2023) to display sf objects.\n\nlibrary(mapsf)\nmf_map(mun, col = \"ivory4\", border = \"ivory\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\n\nPlot municpalities with sf. The filling color must be blue and borders must be thick.\nPlot municipalities with mapsf. The filling color must be lightgreen and borders must be white and thin.\nAdd the restaurants to the municpalities map.\nHow many municipalities are there?\nWhich commune has the largest population?",
    "crumbs": [
      "**II. Vector Data & Geoprocessing**",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector Data</span>"
    ]
  },
  {
    "objectID": "1_vector_data.html#coordinate-reference-systems-crs",
    "href": "1_vector_data.html#coordinate-reference-systems-crs",
    "title": "2¬† Vector Data",
    "section": "2.7 Coordinate Reference Systems (CRS)",
    "text": "2.7 Coordinate Reference Systems (CRS)\n\n2.7.1 Inspect the CRS of an sf object\nThe st_crs() function lets you inspect the CRS used by an sf object.\n\nlibrary(sf) \nst_crs(x = mun)\n\n#&gt; Coordinate Reference System:\n#&gt;   User input: RGF93 v1 / Lambert-93 \n#&gt;   wkt:\n#&gt; PROJCRS[\"RGF93 v1 / Lambert-93\",\n#&gt;     BASEGEOGCRS[\"RGF93 v1\",\n#&gt;         DATUM[\"Reseau Geodesique Francais 1993 v1\",\n#&gt;             ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n#&gt;                 LENGTHUNIT[\"metre\",1]]],\n#&gt;         PRIMEM[\"Greenwich\",0,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#&gt;         ID[\"EPSG\",4171]],\n#&gt;     CONVERSION[\"Lambert-93\",\n#&gt;         METHOD[\"Lambert Conic Conformal (2SP)\",\n#&gt;             ID[\"EPSG\",9802]],\n#&gt;         PARAMETER[\"Latitude of false origin\",46.5,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8821]],\n#&gt;         PARAMETER[\"Longitude of false origin\",3,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8822]],\n#&gt;         PARAMETER[\"Latitude of 1st standard parallel\",49,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8823]],\n#&gt;         PARAMETER[\"Latitude of 2nd standard parallel\",44,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8824]],\n#&gt;         PARAMETER[\"Easting at false origin\",700000,\n#&gt;             LENGTHUNIT[\"metre\",1],\n#&gt;             ID[\"EPSG\",8826]],\n#&gt;         PARAMETER[\"Northing at false origin\",6600000,\n#&gt;             LENGTHUNIT[\"metre\",1],\n#&gt;             ID[\"EPSG\",8827]]],\n#&gt;     CS[Cartesian,2],\n#&gt;         AXIS[\"easting (X)\",east,\n#&gt;             ORDER[1],\n#&gt;             LENGTHUNIT[\"metre\",1]],\n#&gt;         AXIS[\"northing (Y)\",north,\n#&gt;             ORDER[2],\n#&gt;             LENGTHUNIT[\"metre\",1]],\n#&gt;     USAGE[\n#&gt;         SCOPE[\"Engineering survey, topographic mapping.\"],\n#&gt;         AREA[\"France - onshore and offshore, mainland and Corsica (France m√©tropolitaine including Corsica).\"],\n#&gt;         BBOX[41.15,-9.86,51.56,10.38]],\n#&gt;     ID[\"EPSG\",2154]]\n\n\n\n\n2.7.2 Transform the CRS of an sf object\nThe st_transform() function can be used to change the coordinate system of an sf object and reproject it.\nmf_map(mun, expandBB = c(0, .12, 0, 0))\nmf_graticule(x = mun)\nmf_title(\"RGF93 / Lambert-93\")\n# CRS change\nmun_reproj &lt;- st_transform(x = mun, crs = \"EPSG:3035\")\nmf_map(mun_reproj, expandBB = c(0, .12, .0, 0))\nmf_graticule(x = mun_reproj)\nmf_title(\"ETRS89-extended / LAEA Europe\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMore\n\n\n\nCoordinate reference systems conversion and transformation, on sf website.",
    "crumbs": [
      "**II. Vector Data & Geoprocessing**",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector Data</span>"
    ]
  },
  {
    "objectID": "1_vector_data.html#attribute-selection-and-join",
    "href": "1_vector_data.html#attribute-selection-and-join",
    "title": "2¬† Vector Data",
    "section": "2.8 Attribute selection and join",
    "text": "2.8 Attribute selection and join\n\n2.8.1 Selection by attributes\nAs sf objects are data.frames, we can select their rows and columns in the same way as data.frames.\n\n# row selection\nmun[1:2, ]\n\n#&gt; Simple feature collection with 2 features and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 557759.2 ymin: 6371852 xmax: 607179 ymax: 6410204\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;   INSEE_COM NOM_COM         STATUT POPULATION    AGR_H    AGR_F    IND_H IND_F\n#&gt; 1     46001   Albas Commune simple        522 4.978581 0.000000 4.936153     0\n#&gt; 2     46002  Albiac Commune simple         67 0.000000 9.589041 0.000000     0\n#&gt;      BTP_H BTP_F     TER_H     TER_F                           geom\n#&gt; 1 9.957527     0 44.917145 34.681799 MULTIPOLYGON (((559262 6371...\n#&gt; 2 4.794521     0  4.794521  9.589041 MULTIPOLYGON (((605540.7 64...\n\nmun[mun$NOM_COM == \"Gramat\", ]\n\n#&gt; Simple feature collection with 1 feature and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 593605.6 ymin: 6402330 xmax: 602624.6 ymax: 6413784\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;     INSEE_COM NOM_COM         STATUT POPULATION    AGR_H    AGR_F    IND_H\n#&gt; 119     46128  Gramat Commune simple       3468 10.19868 15.29802 122.3842\n#&gt;        IND_F    BTP_H BTP_F    TER_H    TER_F                           geom\n#&gt; 119 107.0862 56.09275     0 260.0664 304.1941 MULTIPOLYGON (((594713.1 64...\n\n# column selection\nmun[, \"POPULATION\"]\n\n#&gt; Simple feature collection with 313 features and 1 field\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 539668.5 ymin: 6346290 xmax: 637380.9 ymax: 6439668\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt; First 10 features:\n#&gt;    POPULATION                           geom\n#&gt; 1         522 MULTIPOLYGON (((559262 6371...\n#&gt; 2          67 MULTIPOLYGON (((605540.7 64...\n#&gt; 3         706 MULTIPOLYGON (((593707.7 64...\n#&gt; 4         219 MULTIPOLYGON (((613211.3 64...\n#&gt; 5         329 MULTIPOLYGON (((556744.9 63...\n#&gt; 6         377 MULTIPOLYGON (((576667.2 64...\n#&gt; 7         988 MULTIPOLYGON (((581404 6370...\n#&gt; 8         203 MULTIPOLYGON (((558216 6389...\n#&gt; 9         642 MULTIPOLYGON (((612729.6 63...\n#&gt; 10        367 MULTIPOLYGON (((581404 6370...\n\nmun[mun$NOM_COM == \"Gramat\", 1:4]\n\n#&gt; Simple feature collection with 1 feature and 4 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 593605.6 ymin: 6402330 xmax: 602624.6 ymax: 6413784\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;     INSEE_COM NOM_COM         STATUT POPULATION                           geom\n#&gt; 119     46128  Gramat Commune simple       3468 MULTIPOLYGON (((594713.1 64...\n\n\n\n\n2.8.2 Attribute join\nWe can join a data.frame and an sf object using merge() if they share a common identifier.\nBe careful with the order of the arguments, as the object returned will be of the same type as x. It is not possible to make an attribute join using two sf objects.\n\n# import additional data \nmun_df &lt;- read.csv(file = \"data/com.csv\")\n\n# common identifiers?\nnames(mun_df)\n\n#&gt; [1] \"INSEE_COM\" \"ACT\"       \"IND\"       \"SACT\"      \"SACT_IND\"\n\nnames(mun)\n\n#&gt;  [1] \"INSEE_COM\"  \"NOM_COM\"    \"STATUT\"     \"POPULATION\" \"AGR_H\"     \n#&gt;  [6] \"AGR_F\"      \"IND_H\"      \"IND_F\"      \"BTP_H\"      \"BTP_F\"     \n#&gt; [11] \"TER_H\"      \"TER_F\"      \"geom\"\n\n# attribute join \nmun_final &lt;- merge(\n  x = mun, # the sf object\n  y = mun_df, # the data.frame\n  by.x = \"INSEE_COM\", # identifier in x\n  by.y = \"INSEE_COM\", # identifier in y\n  all.x = TRUE # keep all lines\n)\n\n# the two objects have been joined\nhead(mun_final, 3)\n\n#&gt; Simple feature collection with 3 features and 16 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 557759.2 ymin: 6371852 xmax: 607179 ymax: 6418606\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;   INSEE_COM  NOM_COM         STATUT POPULATION     AGR_H    AGR_F     IND_H\n#&gt; 1     46001    Albas Commune simple        522  4.978581 0.000000  4.936153\n#&gt; 2     46002   Albiac Commune simple         67  0.000000 9.589041  0.000000\n#&gt; 3     46003 Alvignac Commune simple        706 10.419682 0.000000 10.419682\n#&gt;      IND_F     BTP_H BTP_F     TER_H     TER_F       ACT       IND     SACT\n#&gt; 1 0.000000  9.957527     0 44.917145 34.681799  99.47120  4.936153 19.05579\n#&gt; 2 0.000000  4.794521     0  4.794521  9.589041  28.76712  0.000000 42.93600\n#&gt; 3 5.209841 10.419682     0 57.308249 78.147612 171.92475 15.629522 24.35195\n#&gt;   SACT_IND                           geom\n#&gt; 1 4.962393 MULTIPOLYGON (((559262 6371...\n#&gt; 2 0.000000 MULTIPOLYGON (((605540.7 64...\n#&gt; 3 9.090909 MULTIPOLYGON (((593707.7 64...\n\n\n\n\n\n\n\n\nExercice\n\n\n\n\nImport the com.csv file. This dataset covers all municipalities and includes several additional variables:\n\nworking population (ACT)\nworking population in the industrial sector (IND)\nworking population as a percentage of total population (SACT)\nshare of the working population working in the industrial sector (SACT_IND)\n\nJoin this dataset to the municipality layer.\nExtract municipalities with more than 500 active workers and whose share of active workers in the total population is greater than 30%.\nPlot a map with all municipalities in gray and selected municipalities in red.\n\n\n\n\n\n\n\nGiraud, Timoth√©e. 2023. mapsf: Thematic Cartography. https://CRAN.R-project.org/package=mapsf.\n\n\nPebesma, Edzer. 2018. sf: Simple Features for R. https://CRAN.R-project.org/package=sf.",
    "crumbs": [
      "**II. Vector Data & Geoprocessing**",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector Data</span>"
    ]
  },
  {
    "objectID": "2_geoprocessing.html",
    "href": "2_geoprocessing.html",
    "title": "3¬† Geoprocessing",
    "section": "",
    "text": "3.1 Spatial selection and join",
    "crumbs": [
      "**II. Vector Data & Geoprocessing**",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Geoprocessing</span>"
    ]
  },
  {
    "objectID": "2_geoprocessing.html#spatial-selection-and-join",
    "href": "2_geoprocessing.html#spatial-selection-and-join",
    "title": "3¬† Geoprocessing",
    "section": "",
    "text": "3.1.1 Spatial selection\nst_filter() is used to perform spatial selections. The .predicate argument lets you pick the selection criterion by using one of the ‚Äúgeometric predicate‚Äù functions (e.g.¬†st_intersects(), st_within(), st_crosses()‚Ä¶).\nHere, we‚Äôll select the roads that intersect the municipality of Gramat\n\nmun &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\nroads &lt;- st_read(\"data/lot.gpkg\", layer = \"routes\", quiet = TRUE)\ngramat &lt;-  mun[mun$NOM_COM == \"Gramat\", ]\n\nroad_gramat &lt;-  st_filter(x = roads, \n                          y = gramat,\n                          .predicate = st_intersects)\n# Plot\nlibrary(mapsf)\nmf_map(gramat, col = \"lightblue\")\nmf_map(roads, add = TRUE)\nmf_map(road_gramat, col = \"tomato\", lwd = 2, add = TRUE)  \n\n\n\n\n\n\n\n\n\n\n3.1.2 Spatial join\nst_join() is used to perform spatial joins. Use the join argument to select the geometric predicate.\n\nroad_gramat &lt;-  st_join(x = roads,\n                         y = mun[, \"INSEE_COM\"],\n                         join = st_intersects,\n                         left = FALSE)\nroad_gramat\n\n#&gt; Simple feature collection with 1247 features and 3 fields\n#&gt; Geometry type: LINESTRING\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 587147.6 ymin: 6394844 xmax: 608194.7 ymax: 6420006\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt; First 10 features:\n#&gt;     ID      CLASS_ADM INSEE_COM                           geom\n#&gt; 1    1 D√©partementale     46240 LINESTRING (590557.5 641181...\n#&gt; 2    2 D√©partementale     46240 LINESTRING (593733.2 641429...\n#&gt; 3    3 D√©partementale     46240 LINESTRING (590665 6412381,...\n#&gt; 4    4 D√©partementale     46128 LINESTRING (598940.9 640909...\n#&gt; 5    5 D√©partementale     46104 LINESTRING (603201.9 640181...\n#&gt; 6    6     Sans objet     46235 LINESTRING (598162.3 640108...\n#&gt; 7    7 D√©partementale     46090 LINESTRING (598887.3 639763...\n#&gt; 7.1  7 D√©partementale     46138 LINESTRING (598887.3 639763...\n#&gt; 7.2  7 D√©partementale     46233 LINESTRING (598887.3 639763...\n#&gt; 8    8 D√©partementale     46090 LINESTRING (601184.3 639697...\n\n\n\n\n\n\n\n\nExercice\n\n\n\n\nImport the layers of municipalities and restaurants.\nPerform a spatial join to find the name and identifier of the municipality where each restaurant is located.",
    "crumbs": [
      "**II. Vector Data & Geoprocessing**",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Geoprocessing</span>"
    ]
  },
  {
    "objectID": "2_geoprocessing.html#geometrical-operations",
    "href": "2_geoprocessing.html#geometrical-operations",
    "title": "3¬† Geoprocessing",
    "section": "3.2 Geometrical operations",
    "text": "3.2 Geometrical operations\n\n3.2.1 Centroids\n\nmun_c &lt;- st_centroid(mun)\n\n#&gt; Warning: st_centroid assumes attributes are constant over geometries\n\nmf_map(mun)\nmf_map(mun_c, add = TRUE, cex = 1.2, col = \"red\", pch = 20)\n\n\n\n\n\n\n\n\n\n\n3.2.2 Aggregate polygons\n\ndep_46 &lt;- st_union(mun)\n\nmf_map(mun, col = \"lightblue\")\nmf_map(dep_46, col = NA, border = \"red\", lwd = 2, add = TRUE)\n\n\n\n\n\n\n\n\n\n\n3.2.3 Aggregate polygons using a grouping variable\n\n# Grouping variable\ni &lt;- mun$STATUT \n\nmun_u &lt;- st_sf(\n  STATUT     = tapply(X = mun$STATUT     , INDEX = i, FUN = head, 1),\n  POPULATION = tapply(X = mun$POPULATION , INDEX = i, FUN = sum), \n  geometry   = tapply(X = mun            , INDEX = i, FUN = st_union), \n  crs        = st_crs(mun)\n) \n\n\n\n3.2.4 Buffers\nst_buffer() is used to construct buffer zones. The distance is expressed in units of the projection (st_crs(x)$units).\n\n# Select a municipality\ngramat &lt;- mun[mun$NOM_COM == \"Gramat\", ]\n\ngramat_b &lt;- st_buffer(x = gramat, dist = 5000)\n\nmf_map(gramat_b, col = \"lightblue\", lwd=2, border = \"red\")\nmf_map(gramat, add = TRUE, lwd = 2)\n\n\n\n\n\n\n\n\n\n\n3.2.5 Intersection\nUsing st_intersection(), we can cut one layer by another.\n\n# create a buffer zone around the centroid of Gramat\nzone &lt;- st_geometry(gramat) |&gt; \n  st_centroid() |&gt; \n  st_buffer(10000)\n\nmf_map(mun)\nmf_map(zone, border = \"red\", col = NA, lwd = 2, add = TRUE)\n\n\n\n\n\n\n\nmun_z &lt;- st_intersection(x = mun, y = zone)\n\n#&gt; Warning: attribute variables are assumed to be spatially constant throughout\n#&gt; all geometries\n\nmf_map(mun)\nmf_map(mun_z, col = \"red\", border = \"green\", add = TRUE)\n\n\n\n\n\n\n\nmf_map(mun_z)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn this example, we‚Äôve used pipes (|&gt;). Pipes are used to concatenate a sequence of instructions.\n\n\n\n\n\n3.2.6 Regular grid\nst_make_grid() is used to create a regular grid. It produces an sfc object, and then you need to use st_sf() to transform this sfc object into an sf object. We also add a column of unique identifiers.\n\n# create a grid\ngrid &lt;- st_make_grid(x = mun, cellsize = 5000)\n\n# transform to sf, add identifier\ngrid &lt;- st_sf(ID = 1:length(grid), geom = grid)\n\nmf_map(grid, col = \"grey\", border = \"white\")\nmf_map(mun, col = NA, border = \"grey50\", add = TRUE)\n\n\n\n\n\n\n\n\n\n\n3.2.7 Counting points in polygons\nSelect the grid tiles which intersect the department with st_filter().\n\ngrid &lt;- st_filter(grid, dep_46, .predicate = st_intersects)\n\n# Import restaurants\nrestaurant &lt;- st_read(\"data/lot.gpkg\", layer = \"restaurants\", quiet = TRUE)\n\nmf_map(grid, col = \"grey\", border = \"white\")\nmf_map(restaurant, pch = 20, col = \"red\", cex = .5, add = TRUE)\n\n\n\n\n\n\n\n\nWe then use st_intersects(..., sparse = TRUE), which will produce a list of the elements of the restaurant object inside each element of the grid object (via their indexes).\n\ninter &lt;- st_intersects(grid, restaurant, sparse = TRUE)\n\nlength(inter) == nrow(grid)\n\n#&gt; [1] TRUE\n\n\nTo count the number of restaurants, all we need to do is report the length of each of the elements in this list.\n\ngrid$nb_restaurant &lt;- lengths(inter)\n\nmf_map(grid)\nmf_map(grid, var = \"nb_restaurant\", type = \"prop\")\n\n#&gt; 94 '0' values are not plotted on the map.\n\n\n\n\n\n\n\n\n\n\n\n3.2.8 Geometries simplification\n The rmapshaper package (Teucher and Russell 2023) builds on the Mapshaper JavaScript library (Bloch 2013) to offer several topology-friendly methods for simplifying geometries.\nThe keep argument is used to indicate the level of simplification. The keep_shapes argument is used to keep all polygons when the simplification level is high.\nlibrary(\"rmapshaper\")\nmun_simp1 &lt;- ms_simplify(mun, keep = 0.01 , keep_shapes = TRUE)\nmun_simp2 &lt;- ms_simplify(mun, keep = 0.001, keep_shapes = TRUE)\nmf_map(mun)\nmf_map(mun_simp1)\nmf_map(mun_simp2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\n\nCompute the number of restaurants per municipality.\nWhich municipalities have more than 10 restaurants and fewer than 1000 inhabitants?\nCreate a map showing all the municipalities in grey and the municipalities selected above in red.\n\n\n\n\n\n\n\nBloch, Matthew. 2013. ‚ÄúMapshaper: Tools for editing Shapefile, GeoJSON, TopoJSON and CSV files JavaScript libary.‚Äù https://github.com/mbloch/mapshaper.\n\n\nTeucher, Andy, and Kenton Russell. 2023. Rmapshaper: Client for ‚ÄôMapshaper‚Äô for ‚ÄôGeospatial‚Äô Operations. https://CRAN.R-project.org/package=rmapshaper.",
    "crumbs": [
      "**II. Vector Data & Geoprocessing**",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Geoprocessing</span>"
    ]
  },
  {
    "objectID": "3_cartography.html",
    "href": "3_cartography.html",
    "title": "4¬† The Cartographic Language",
    "section": "",
    "text": "üîó Thematic Cartography - Cartographic Language\n\n\n\nMap semiology decision tree\n\n\n\n\n\n\n\n\nExercice\n\n\n\nHow to represent the following variables:\n\nA municipal population\nA median age by region\nA population growth rate\nThe administrative status of municipalities\nLife expectancy per country",
    "crumbs": [
      "**III. Cartography**",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>The Cartographic Language</span>"
    ]
  },
  {
    "objectID": "4_mapsf.html",
    "href": "4_mapsf.html",
    "title": "5¬† mapsf",
    "section": "",
    "text": "5.1 Presentation\nThe spatial ecosystem of R is rich, dynamic and mature and several packages can be used to import, process and represent spatial data. The mapsf package (Giraud 2023) is a part of this ecosystem and can be used to create high-quality thematic maps.\nIn this document, we will mainly be using the mapsf package, which has fairly comprehensive functionality and is fairly easy to learn. What‚Äôs more, the package is relatively lightweight.\nmapsf can be used to create most of the map types commonly used in statistical cartography (choropleth maps, typologies, proportional or graduated symbols, etc.).\nFor each type of map, a number of parameters can be used to customise the cartographic representation. These parameters are the same as those found in standard GIS or cartography software (for example, the choice of discretisations and colour palettes, changing the size of symbols or customising legends).\nIn addition to the data representation functions, other functions are dedicated to cartographic design (themes or graphic charters, legends, scales, orientation arrows, titles, credits, annotations, etc.), the creation of insets or map export.\nDocumentation",
    "crumbs": [
      "**III. Cartography**",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>`mapsf`</span>"
    ]
  },
  {
    "objectID": "4_mapsf.html#presentation",
    "href": "4_mapsf.html#presentation",
    "title": "5¬† mapsf",
    "section": "",
    "text": "A typical processing chain\n\n\n\n\n\n\n\n\nOther packages can be used to create thematic maps.\nThe ggplot2 package (Wickham 2016), in conjunction with the ggspatial package (Dunnington 2023), can be used to display spatial objects and create simple thematic maps.\nThe tmap package (Tennekes 2018) is dedicated to creating thematic maps, and uses a syntax similar to that of ggplot2 (sequence of instructions combined with the + sign).\nDocumentation and tutorials for using these two packages are readily available on the web.\n\n\n\n\n\n\n\nA minimal number of well-known dependencies\n\n\n\n\n\n\n\n\n\n\nWebsite \n\n\ncheat sheet \n\n\n\n\nVignettes :\n\n\n\nGet started\nHow to create faceted maps\nHow to create inset maps\nHow to export maps\nHow to use a custom font family\nHow to use themes",
    "crumbs": [
      "**III. Cartography**",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>`mapsf`</span>"
    ]
  },
  {
    "objectID": "4_mapsf.html#map-types",
    "href": "4_mapsf.html#map-types",
    "title": "5¬† mapsf",
    "section": "5.2 Map Types",
    "text": "5.2 Map Types\nmf_map() is the main function of the package, it displays map layers on a georeferenced plot.\nmf_map() has three main arguments:\n\nx, an sf object;\nvar, the name(s) of a variable(s) to map;\ntype, the map layer type.\n\nMany parameters are available to fine tune symbologies and legends.\n\n5.2.1 Sample data set\nImport map layers from the geopackage file lot.gpkg.\n\nlibrary(sf)\n# import municipalities\nmun &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\n# import french departements \ndep &lt;- st_read(\"data/lot.gpkg\", layer = \"departements\", quiet = TRUE)\n# import restaurants\nresto &lt;- st_read(\"data/lot.gpkg\", layer = \"restaurants\", quiet = TRUE)\n# import someroads\nroad &lt;- st_read(\"data/lot.gpkg\", layer = \"routes\", quiet = TRUE)\n\n\n\n5.2.2 Geometries / Base Maps\nmf_map(x, type = \"base\") displays sf objects geometries.\n\nlibrary(mapsf)\n# polygones\nmf_map(x = mun, border = \"white\")\n# departements (polygones, transparent background)\nmf_map(x = dep, lwd = 2, col = NA, add = TRUE)\n# roads (polylines)\nmf_map(x = road, lwd = .7, col = \"ivory4\", add = TRUE)\n# restaurants (points)\nmf_map(x = resto, pch = 20, cex = .7, col = \"darkred\", add = TRUE)\n# title\nmf_title(txt = \"Le Lot (46)\")\n\n\n\n\n\n\n\n\n\n\n5.2.3 Proportional Symbols\nmf_map(x, var, type = \"prop\") displays symbols with areas proportional to a quantitative variable (stocks). The inches argument is used to customize the symbols sizes.\n\n# plot municipalities \nmf_map(x = mun)\n# proportional symbols\nmf_map(\n  x = mun, \n  var = \"POPULATION\",\n  type = \"prop\",\n  leg_title = \"Total Population\\n(2015)\"\n)\n# Titre\nmf_title(\"Population Distribution\")\n\n\n\n\n\n\n\n\n\n\n5.2.4 Choropleth Map\nIn choropleth maps, areas are shaded according to the variation of a quantitative variable. They are used to represent ratios or indices. mf_map(x, var, type = \"choro\") displays choropleth maps . Arguments nbreaks, and breaks allow to customize the variable classification.\n\n# Population density (inhab./km¬≤) using sf::st_area()\nmun$pop_density &lt;- 1e6 * mun$POPULATION / as.numeric(st_area(mun))\nmf_map(\n  x = mun,\n  var = \"pop_density\",\n  type = \"choro\",\n  breaks = \"quantile\",\n  nbreaks = 6,\n  pal = \"Dark Mint\",\n  lwd = 1,\n  leg_title = \"Population Density\\n(inh./km¬≤)\", \n  leg_val_rnd = 0\n)\nmf_title(\"Population Distribution (2018)\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nColor palettes\n\n\n\nColor palettes, defined with pal, can be created with mf_get_pal() or you can use palette names from hcl.pals().\nmf_map(x = mun, var = \"pop_density\", type = \"choro\",\n       breaks = \"quantile\", nbreaks = 4, \n       pal = \"Peach\")\nmf_title(\"Named palette\")\nma_palette &lt;- c(\"#F3CAD2\", \"#E08BB1\", \"#AF4F91\", \"#6D1C68\")\nmf_map(x = mun, var = \"pop_density\", type = \"choro\",\n       breaks = \"quantile\", nbreaks = 4, \n       pal = ma_palette)\nmf_title(\"Vector of colors\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nBuiltin R color palettes\n\n\n\n\n\n\n\n\n\n\nClassifications\n\n\n\nBefore creating a choropleth map, we must first study the statistical distribution of the variable we wish to map. The mf_distr() function is used to visualise distributions.\n\nmf_distr(mun$pop_density)\n\n\n\n\n\n\n\n\nThis distribution is very skewed to the left.\nmf_get_breaks() can be used to classify continuous variables. Many classification methods are available ( ‚Äúfixed‚Äù, ‚Äúsd‚Äù, ‚Äúequal‚Äù, ‚Äúpretty‚Äù, ‚Äúquantile‚Äù, ‚Äúkmeans‚Äù, ‚Äúhclust‚Äù, ‚Äúbclust‚Äù, ‚Äúfisher‚Äù, ‚Äújenks‚Äù, ‚Äúdpih‚Äù, ‚Äúq6‚Äù, ‚ÄúQ6‚Äù, geom‚Äù, ‚Äúarith‚Äù, ‚Äúem‚Äù, ‚Äúmsd‚Äù or ‚Äúckmeans‚Äù).\nHere, using the ‚Äògeom‚Äô method is quite appropriate.\n\n(bks &lt;- mf_get_breaks(x = mun$pop_density, nbreaks = 5, breaks = \"geom\"))\n\n#&gt; [1]   4.113775  11.033758  29.594181  79.376000 212.898252 571.024813\n\nmf_map(\n  x = mun, var = \"pop_density\", type = \"choro\",\n  breaks = bks, pal = \"Blues\",\n  lwd = 1,\n  leg_title = \"Population Density\\n(inh./km¬≤)\", \n  leg_val_rnd = 0\n)\nmf_title(\"Population Distribution (2018)\")\n\n\n\n\n\n\n\n\n\n\n\n\n5.2.5 Typology Map\nmf_map(x, var, type = \"typo\") displays a typology map of a qualitative variable. val_order is used to set the modalities order in the legend.\n\nmf_map(\n  x = mun,\n  var = \"STATUT\",\n  type = \"typo\",\n  pal = c(\"aquamarine4\", \"yellow3\",\"wheat\"),\n  lwd = .7,\n  leg_title = \"\"\n)\nmf_title(\"Municipality Administrative Status\")\n\n\n\n\n\n\n\n\nThe val_order argument is used to order the modalities in the legend.\n\nmf_map(\n  x = mun,\n  var = \"STATUT\",\n  type = \"typo\",\n  pal = c(\"aquamarine4\", \"yellow3\",\"wheat\"),\n  val_order = c(\"Pr√©fecture\", \"Sous-pr√©fecture\", \"Commune simple\"),\n  lwd = .7,\n  leg_title = \"\"\n)\nmf_title(\"Municipality Administrative Status\")\n\n\n\n\n\n\n\n\n\n\n5.2.6 Proportional Symbols using Choropleth Coloration\nmf_map(x, var, type = \"prop_choro\") creates a map of symbols that are proportional to values of a first variable and colored to reflect the classification of a second variable.\n\nmf_map(x = mun)\nmf_map(\n  x = mun,\n  var = c(\"POPULATION\", \"pop_density\"),\n  type = \"prop_choro\",\n  border = \"grey50\",\n  lwd = 1,\n  leg_title = c(\"Population\", \"Population Density\\n(inh./km¬≤)\"),\n  breaks = \"q6\",\n  pal = \"Magenta\",\n  leg_val_rnd = c(0,1))\nmf_title(\"Population Distribution (2018)\")\n\n\n\n\n\n\n\n\n\n\n5.2.7 Proportional Symbols using Typology Coloration\nmf_map(x, var, type = \"prop_typo\") creates a map of symbols that are proportional to values of a first variable and colored to reflect the modalities of a second qualitative variable.\n\nmf_map(x = mun)\nmf_map(\n  x = mun,\n  var = c(\"POPULATION\", \"STATUT\"),\n  type = \"prop_typo\",\n  pal = c(\"aquamarine4\", \"yellow3\",\"wheat\"),\n  val_order = c(\"Pr√©fecture\", \"Sous-pr√©fecture\", \"Commune simple\"),\n  leg_pos = \"topleft\",\n  leg_title = c(\"Population\\n(2015)\",\n                \"Administrative Status\"),\n)\nmf_title(\"Population Distribution (2018)\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\n\nImport the com.csv file. This dataset covers all municipalities and includes several additional variables:\n\nworking population (ACT)\nworking population in the industrial sector (IND)\nworking population as a percentage of total population (SACT)\nshare of the working population working in the industrial sector (SACT_IND)\n\nJoin this dataset to the municipality layer.\nCreate a map of the working population. Which type of map should be used? What choices does this involve?\nCreate a map of the share of the working population in the total population. Which type of map should be used? What choices does this involve?",
    "crumbs": [
      "**III. Cartography**",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>`mapsf`</span>"
    ]
  },
  {
    "objectID": "4_mapsf.html#map-layout",
    "href": "4_mapsf.html#map-layout",
    "title": "5¬† mapsf",
    "section": "5.3 Map Layout",
    "text": "5.3 Map Layout\n\n5.3.1 Titles, scale bar, North arrow, credits\nmf_title() displays a title.\nmf_arrow() displays a North arrow.\nmf_scale() displays a scale bar.\nmf_credits() plots credits at the bottom of the map.\n\nmf_map(mun)\nmf_title()\nmf_scale()\nmf_arrow()\nmf_credits()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmf_layout() combines these elements and add a complete layout to the map (title, credits, north arrow, scale bar).\n\nmf_map(mun)\nmf_layout(\n  title = \"Lot\", \n  credits = \"Authors : TG & HP\\nSources : IGN, 2018\",\n  arrow = TRUE, \n  scale = TRUE\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n5.3.2 Legends\nmf_legend() displays legends.\n\nmf_map(mun)\nmf_legend(\n  type = \"prop\", \n  val = c(1000,500,200,10), \n  inches = .4, \n  pos = \"topleft\"\n)\nmf_legend(\n  type = \"choro\", \n  val = c(0,10,20,30,40),\n  pal = \"Greens\", \n  pos = \"bottomright\", \n  val_rnd = 0\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInteractive placement of layout elements\n\n\n\nSome layout elements can be positioned interactively on the map by using ‚Äúinteractive‚Äù as position. This applies to legends, north arrow, scale bar.\n\n\n\n\n\n5.3.3 Labels and Annotations\nmf_label() is dedicated to the display of labels on a map. Use the overlap = FALSE argument to displays non overlapping labels.\nmf_annotation() displays an annotation on a single spatial feature.\n\n# select a municipality\ncahors &lt;- mun[mun$NOM_COM == \"Cahors\", ]\n# Select municipalities intersecting Cahors\ncahors_neighbors &lt;- st_filter(x = mun, y = cahors, .predicate = st_intersects)\nmf_map(cahors_neighbors)\nmf_label(\n  x = cahors_neighbors,\n  var = \"NOM_COM\",\n  col= \"black\",\n  halo = TRUE,\n  overlap = FALSE, \n  lines = FALSE\n)\n\nmf_annotation(\n  x =c(582000, 6369000), \n  txt = \"This place is\\nvery specific\", \n  halo = TRUE, \n  cex = 1.5\n)\n\n\n\n\n\n\n\n\n\n\n5.3.4 Center the map on a specific area\nThe mf_map() function can start a map by centering it on a spatial object and setting transparent background and borders.\n\nmf_map(cahors_neighbors, col = NA, border = NA)\nmf_map(mun, add = TRUE)\nmf_map(mun, \"POPULATION\", \"prop\", leg_frame = TRUE)\n\n\n\n\n\n\n\n\n\n\n5.3.5 Display several maps on the same figure\nTo plot several maps on the same figure, the user can use the mfrow argument of the par() function before plotting the maps. For example, use par(mfrow = c(1, 2)) (i.e.¬†1 row, 2 columns) to plot two maps side by side).\n\n# define the figure layout (1 row, 2 columns)\nopar &lt;- par(mfrow = c(1, 2))\n# first map\nmf_map(mun)\nmf_map(mun, \"TER_F\", \"prop\", \n       inches = .2,\n       val_max = 4000, \n       leg_pos = \"topleft\", \n       leg_title = \"N.\")\nmf_title(\"Tertiary workers: Women\")\n# second map\nmf_map(mun)\nmf_map(mun, \"TER_H\", \"prop\",\n       inches = .2,\n       val_max = 4000, \n       leg_pos = NA)\nmf_title(\"Men\")\npar(opar)\n\n\n\n\n\n\n\n\n\n\n5.3.6 Export maps\nmf_export() exports maps in PNG or SVG formats.\nThe exported map width/height ratio will match the one of a spatial object.\nIf width is specified, then height is deduced from the width/height ratio of x, figure margins and title size.\nIf height is specified, then width is deduced from the width/height ratio of x, figure margins and title size.\n\n\n\n\n\n\nAlways use add = TRUE after mf_export() and do not forget to add dev.off() at the end of the export.\n\n\n\n\nmf_export(\n  x = mun, \n  filename = \"img/mun_default.png\",\n  width = 600\n)\nmf_map(mun, add = TRUE)\nmf_title(\"Lot\")\ndev.off()\n\n\nIn the following export we have added some space on the right side of the plot (50% of x width).\n\nmf_export(\n  x = mun, \n  filename = \"img/mun_expand.png\",\n  width = 600, \n  expandBB = c(0, 0, 0, .5)\n)\nmf_map(mun, add = TRUE)\nmf_title(\"Le Lot\")\ndev.off()\n\n\n\n\n\n\n\n\nVignette\n\n\n\nHow to Export Maps\n\n\n\n\n5.3.7 Add an image on the map\nreadPNG() from the png package can be used to add an image on a map.\n\nlibrary(png)\n# image import\nlogo &lt;- readPNG(\"img/Logo CG 46 - Bleu.png\")\n# image dimension\npp &lt;- dim(logo)[2:1] * 20\n# Coordinates of the topleft corner of com bounding box\nxy &lt;- st_bbox(com)[c(1,4)]\nmf_map(com, col = \"#D1914D\", border = \"white\")\nrasterImage(\n  image   = logo,\n  xleft   = xy[1],\n  ybottom = xy[2] - pp[2],\n  xright  = xy[1] + pp[1],\n  ytop    = xy[2]\n)\n\n\n\n\n\n\n\n\n\n\n5.3.8 Add a shadow to a layer\nmf_shadow() plots the shadow of a polygon layer.\n\nmf_shadow(com)\nmf_map(com, add=TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\n\nCreate a map showing the working population in the industrial sector.\nAdd the necessary layout elements.\nMake the map more intelligible, more explicit.\nExport the map in PNG format, 1000 pixels wide.\n\n\n\n\n\n\n\nDunnington, Dewey. 2023. ggspatial: Spatial Data Framework for ggplot2. https://CRAN.R-project.org/package=ggspatial.\n\n\nGiraud, Timoth√©e. 2023. mapsf: Thematic Cartography. https://CRAN.R-project.org/package=mapsf.\n\n\nTennekes, Martijn. 2018. ‚Äútmap: Thematic Maps in R.‚Äù Journal of Statistical Software 84 (6): 1‚Äì39. https://doi.org/10.18637/jss.v084.i06.\n\n\nWickham, Hadley. 2016. ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York. https://ggplot2.tidyverse.org.",
    "crumbs": [
      "**III. Cartography**",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>`mapsf`</span>"
    ]
  },
  {
    "objectID": "2000_references.html",
    "href": "2000_references.html",
    "title": "References",
    "section": "",
    "text": "Bloch, Matthew. 2013. ‚ÄúMapshaper: Tools for\nediting Shapefile, GeoJSON, TopoJSON and CSV files JavaScript\nlibary.‚Äù https://github.com/mbloch/mapshaper.\n\n\nDunnington, Dewey. 2023. ggspatial: Spatial\nData Framework for ggplot2. https://CRAN.R-project.org/package=ggspatial.\n\n\nGiraud, Timoth√©e. 2023. mapsf: Thematic\nCartography. https://CRAN.R-project.org/package=mapsf.\n\n\nGiraud, Timoth√©e, and Hugues Pecout. 2024a. ‚ÄúCartographie avec R.‚Äù https://doi.org/10.5281/zenodo.5905734.\n\n\n‚Äî‚Äî‚Äî. 2024b. ‚ÄúG√©omatique avec\nR.‚Äù https://doi.org/10.5281/zenodo.5906212.\n\n\nHijmans, Robert J. 2025. Spatial Data Science\nwith R and \"terra\". https://rspatial.org.\n\n\nLovelace, Robin, Jakub Nowosad, and Jannes Muenchow. 2025.\nGeocomputation with R. Chapman; Hall/CRC. https://r.geocompx.org/.\n\n\nPebesma, Edzer. 2018. sf: Simple Features for\nR. https://CRAN.R-project.org/package=sf.\n\n\nPebesma, Edzer, and Roger Bivand. 2023. Spatial\nData Science: With applications in R. Chapman; Hall/CRC. https://doi.org/10.1201/9780429459016.\n\n\nTennekes, Martijn. 2018. ‚Äútmap:\nThematic Maps in R.‚Äù Journal of Statistical\nSoftware 84 (6): 1‚Äì39. https://doi.org/10.18637/jss.v084.i06.\n\n\nTeucher, Andy, and Kenton Russell. 2023. Rmapshaper: Client for\n‚ÄôMapshaper‚Äô for ‚ÄôGeospatial‚Äô Operations. https://CRAN.R-project.org/package=rmapshaper.\n\n\nWickham, Hadley. 2016. ggplot2: Elegant\nGraphics for Data Analysis. Springer-Verlag New York. https://ggplot2.tidyverse.org.",
    "crumbs": [
      "References"
    ]
  }
]